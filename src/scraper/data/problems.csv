DSA|Title|Level|Question
Math & Geometry|Pow(x, n)|Medium|<div class="elfjS" data-track-load="description_content"><p>Implement <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x<sup>n</sup></code>).</p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> x = 2.00000, n = 10 <strong>Output:</strong> 1024.00000 </pre> <p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> x = 2.10000, n = 3 <strong>Output:</strong> 9.26100 </pre> <p><strong class="example">Example 3:</strong></p> <pre><strong>Input:</strong> x = 2.00000, n = -2 <strong>Output:</strong> 0.25000 <strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25 </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>-100.0 &lt; x &lt; 100.0</code></li> 	<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li> 	<li><code>n</code> is an integer.</li> 	<li>Either <code>x</code> is not zero or <code>n &gt; 0</code>.</li> 	<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li> </ul> </div>
Math & Geometry|Multiply Strings|Medium|<div class="elfjS" data-track-load="description_content"><p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p> <p><strong>Note:</strong>&nbsp;You must not use any built-in BigInteger library or convert the inputs to integer directly.</p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> num1 = "2", num2 = "3" <strong>Output:</strong> "6" </pre><p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> num1 = "123", num2 = "456" <strong>Output:</strong> "56088" </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li> 	<li><code>num1</code> and <code>num2</code> consist of digits only.</li> 	<li>Both <code>num1</code> and <code>num2</code>&nbsp;do not contain any leading zero, except the number <code>0</code> itself.</li> </ul> </div>
Math & Geometry|Detect Squares|Medium|<div class="elfjS" data-track-load="description_content"><p>You are given a stream of points on the X-Y plane. Design an algorithm that:</p> <ul> 	<li><strong>Adds</strong> new points from the stream into a data structure. <strong>Duplicate</strong> points are allowed and should be treated as different points.</li> 	<li>Given a query point, <strong>counts</strong> the number of ways to choose three points from the data structure such that the three points and the query point form an <strong>axis-aligned square</strong> with <strong>positive area</strong>.</li> </ul> <p>An <strong>axis-aligned square</strong> is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.</p> <p>Implement the <code>DetectSquares</code> class:</p> <ul> 	<li><code>DetectSquares()</code> Initializes the object with an empty data structure.</li> 	<li><code>void add(int[] point)</code> Adds a new point <code>point = [x, y]</code> to the data structure.</li> 	<li><code>int count(int[] point)</code> Counts the number of ways to form <strong>axis-aligned squares</strong> with point <code>point = [x, y]</code> as described above.</li> </ul> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <img alt="" src="https://assets.leetcode.com/uploads/2021/09/01/image.png" style="width: 869px; height: 504px;"> <pre><strong>Input</strong> ["DetectSquares", "add", "add", "add", "count", "count", "add", "count"] [[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]] <strong>Output</strong> [null, null, null, null, 1, 0, null, 2] <strong>Explanation</strong> DetectSquares detectSquares = new DetectSquares(); detectSquares.add([3, 10]); detectSquares.add([11, 2]); detectSquares.add([3, 2]); detectSquares.count([11, 10]); // return 1. You can choose:                                //   - The first, second, and third points detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure. detectSquares.add([11, 2]);    // Adding duplicate points is allowed. detectSquares.count([11, 10]); // return 2. You can choose:                                //   - The first, second, and third points                                //   - The first, third, and fourth points </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>point.length == 2</code></li> 	<li><code>0 &lt;= x, y &lt;= 1000</code></li> 	<li>At most <code>3000</code> calls <strong>in total</strong> will be made to <code>add</code> and <code>count</code>.</li> </ul> </div>
Bit Manipulation|Single Number|Easy|<div class="elfjS" data-track-load="description_content"><p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p> <p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> nums = [2,2,1] <strong>Output:</strong> 1 </pre><p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> nums = [4,1,2,1,2] <strong>Output:</strong> 4 </pre><p><strong class="example">Example 3:</strong></p> <pre><strong>Input:</strong> nums = [1] <strong>Output:</strong> 1 </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li> 	<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li> 	<li>Each element in the array appears twice except for one element which appears only once.</li> </ul> </div>
Bit Manipulation|Number of 1 Bits|Easy|<div class="elfjS" data-track-load="description_content"><p>Write a function that takes the binary representation of a positive integer and returns the number of <span data-keyword="set-bit" class=" cursor-pointer relative text-dark-blue-s text-sm"><div class="popover-wrapper inline-block" data-headlessui-state=""><div><div aria-expanded="false" data-headlessui-state="" id="headlessui-popover-button-:rj:"><div>set bits</div></div><div style="position: fixed; z-index: 40; inset: 0px auto auto 0px; transform: translate(145px, 206px);"></div></div></div></span> it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank">Hamming weight</a>).</p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">n = 11</span></p> <p><strong>Output:</strong> <span class="example-io">3</span></p> <p><strong>Explanation:</strong></p> <p>The input binary string <strong>1011</strong> has a total of three set bits.</p> </div> <p><strong class="example">Example 2:</strong></p> <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">n = 128</span></p> <p><strong>Output:</strong> <span class="example-io">1</span></p> <p><strong>Explanation:</strong></p> <p>The input binary string <strong>10000000</strong> has a total of one set bit.</p> </div> <p><strong class="example">Example 3:</strong></p> <div class="example-block"> <p><strong>Input:</strong> <span class="example-io">n = 2147483645</span></p> <p><strong>Output:</strong> <span class="example-io">30</span></p> <p><strong>Explanation:</strong></p> <p>The input binary string <strong>1111111111111111111111111111101</strong> has a total of thirty set bits.</p> </div> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>1 &lt;= n&nbsp;&lt;= 2<sup>31</sup>&nbsp;- 1</code></li> </ul> <p>&nbsp;</p> <strong>Follow up:</strong> If this function is called many times, how would you optimize it?</div>
Bit Manipulation|Counting Bits|Easy|<div class="elfjS" data-track-load="description_content"><p>Given an integer <code>n</code>, return <em>an array </em><code>ans</code><em> of length </em><code>n + 1</code><em> such that for each </em><code>i</code><em> </em>(<code>0 &lt;= i &lt;= n</code>)<em>, </em><code>ans[i]</code><em> is the <strong>number of </strong></em><code>1</code><em><strong>'s</strong> in the binary representation of </em><code>i</code>.</p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> n = 2 <strong>Output:</strong> [0,1,1] <strong>Explanation:</strong> 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 </pre> <p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> n = 5 <strong>Output:</strong> [0,1,1,2,1,2] <strong>Explanation:</strong> 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 3 --&gt; 11 4 --&gt; 100 5 --&gt; 101 </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>0 &lt;= n &lt;= 10<sup>5</sup></code></li> </ul> <p>&nbsp;</p> <p><strong>Follow up:</strong></p> <ul> 	<li>It is very easy to come up with a solution with a runtime of <code>O(n log n)</code>. Can you do it in linear time <code>O(n)</code> and possibly in a single pass?</li> 	<li>Can you do it without using any built-in function (i.e., like <code>__builtin_popcount</code> in C++)?</li> </ul> </div>
Bit Manipulation|Reverse Bits|Easy|<div class="elfjS" data-track-load="description_content"><p>Reverse bits of a given 32 bits unsigned integer.</p> <p><strong>Note:</strong></p> <ul> 	<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.</li> 	<li>In Java, the compiler represents the signed integers using <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">2's complement notation</a>. Therefore, in <strong class="example">Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li> </ul> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> n = 00000010100101000001111010011100 <strong>Output:</strong>    964176192 (00111001011110000010100101000000) <strong>Explanation: </strong>The input binary string <strong>00000010100101000001111010011100</strong> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <strong>00111001011110000010100101000000</strong>. </pre> <p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> n = 11111111111111111111111111111101 <strong>Output:</strong>   3221225471 (10111111111111111111111111111111) <strong>Explanation: </strong>The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10111111111111111111111111111111</strong>. </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li>The input must be a <strong>binary string</strong> of length <code>32</code></li> </ul> <p>&nbsp;</p> <p><strong>Follow up:</strong> If this function is called many times, how would you optimize it?</p> </div>
Bit Manipulation|Missing Number|Easy|<div class="elfjS" data-track-load="description_content"><p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> nums = [3,0,1] <strong>Output:</strong> 2 <strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. </pre> <p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> nums = [0,1] <strong>Output:</strong> 2 <strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. </pre> <p><strong class="example">Example 3:</strong></p> <pre><strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1] <strong>Output:</strong> 8 <strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>n == nums.length</code></li> 	<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li> 	<li><code>0 &lt;= nums[i] &lt;= n</code></li> 	<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li> </ul> <p>&nbsp;</p> <p><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?</p> </div>
Bit Manipulation|Sum of Two Integers|Medium|<div class="elfjS" data-track-load="description_content"><p>Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code>.</p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> a = 1, b = 2 <strong>Output:</strong> 3 </pre><p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> a = 2, b = 3 <strong>Output:</strong> 5 </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>-1000 &lt;= a, b &lt;= 1000</code></li> </ul> </div>
Bit Manipulation|Reverse Integer|Medium|<div class="elfjS" data-track-load="description_content"><p>Given a signed 32-bit integer <code>x</code>, return <code>x</code><em> with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then return <code>0</code>.</p> <p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p> <p>&nbsp;</p> <p><strong class="example">Example 1:</strong></p> <pre><strong>Input:</strong> x = 123 <strong>Output:</strong> 321 </pre> <p><strong class="example">Example 2:</strong></p> <pre><strong>Input:</strong> x = -123 <strong>Output:</strong> -321 </pre> <p><strong class="example">Example 3:</strong></p> <pre><strong>Input:</strong> x = 120 <strong>Output:</strong> 21 </pre> <p>&nbsp;</p> <p><strong>Constraints:</strong></p> <ul> 	<li><code>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</code></li> </ul> </div>